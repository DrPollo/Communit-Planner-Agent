// init agents from users, registers agents in users status

// each agent is initialised with:
// 1) the community clock
// 2) condition generator
// 3) status generator
// 4) event generator
// 5) action generator

// agent has internal phases defined by
// list of actions he can perform
// preferences
// in training
// use emerging events as a malus for the next round of actions


// going out of the area > bring modifiers

// the delta of outcomes > create new conditions? or trigger emergency?

// pipeline of interventions to be done, eventually the next day?

// degree of relations between agents
import uniqid from 'uniqid';
import Actions from '../Actions/index.js';
import Conditions from '../Conditions/index.js';
import Interact from "../Interact/index.js";
import Utils from '../../Utils/index.js';
import STATUS from './status.js';
import SKILLS from './skills.js';
import ROLES from './roles.js';
import Monitoring from '../Monitoring/index.js';

const Time = Utils.time;
const Messages = Interact.messaging;
const Rate = Utils.rate;
const mergeMaps = Utils.mergeMaps;

export default class Agent{
    // input the state of the agent
    // {age, conditions, state, role, skills}
    // otherwise it is generated by the class
    constructor(agent,clock = new Time.Clock('day'),board){
        this.HOURS = 24;
        this.clock = clock;

        this.id = agent && agent.id ? agent.id : uniqid;
        this.address = agent && agent.address ? agent.address: `agent-${agent.name}-${this.id}`;


        // init with the agent information
        let {age = 0, conditions = [], role, state, skills} = agent;
        // init year of birth
        this.yearOfBirth = this.clock.yearOfBirth(age);
        // console.log('year of birth',this.yearOfBirth);



        // init role
        this.role = this._initRole(role);
        // console.log('agent role',this.role);
        //init skills (provided or randomly generated
        this.skillsMap = this._initSkills(skills);
        // console.log('agent skills',this.skillsMap);



        // console.log('role ',this.role);
        // init agent's status: active, independent, dependent
        this.status = Rate.pickOne(STATUS);
        // console.log('current status ',this.status);

        // init helpers
        this.actionsHelper = new Actions(this.yearOfBirth,this.clock);
        // init conditions helper
        this.conditionsHelper = new Conditions({age,conditions},this.clock);



        // if billboard provided, enable messanging
        if(board){
            this.messaging = new Messages(board);
        }

    }
    get age(){
        return this.clock.age(this.yearOfBirth);
    }
    // returns an array with the current conditions of the agent
    get conditions(){
        return Array.from(this.conditionsHelper.status);
    }
    get skills(){
        return Array.from(this.skillsMap.values());
    }


    //
    dailyRoutine(events = []){
        // evaluate impact of events
        // console.log('today events',events);
        let eventsEffects = events.reduce((partial,event)=>{
            // console.log(event.effects);
            partial.action = partial.action.concat(event.action);
            partial.condition = partial.condition.concat(event.condition);
            return partial;
        },{action:[],condition:[]});
        // console.log('effects of events, actions\n',eventsEffects.action);
        // console.log('effects of events, conditions\n',eventsEffects.condition);
        // add conditions
        this.conditionsHelper.add(eventsEffects.condition);
        // assess events actions
        let eventsOutcomes = this.actionsHelper.outcomes(eventsEffects.action,[],this.conditionsHelper.list);


        // get reminders of daily activities
        let dailies = this.actionsHelper.remind(this.conditions);
        // decide what to do and skip
        let choices = this._decideActions(dailies);


        // IMPORTANT it can be done in bulk or cycle (for the sake of logs)
        // evaluate outcomes of actions
        let actionsOutcomes = this.actionsHelper.outcomes(
            choices.actions,
            choices.skips,
            this.conditionsHelper.list,
            eventsOutcomes.time);


        // IMPORTANT AS BULK //
        // translate outcomes to conditions
        let positive = this._mergeOutcomes([actionsOutcomes.positive,eventsOutcomes.positive]);
        let negative = this._mergeOutcomes([actionsOutcomes.negative,eventsOutcomes.negative]);
        // console.log('consolidate positive',positive);
        // console.log('consolidate negative',negative);
        let issues = this.conditionsHelper.assess(positive,negative);
        // console.log('emerging issues',issues);
        // issues : object {type:weight} (condition type)
        // add for emerging conditions using emerging issues
        let emergingConditions = this.conditionsHelper.addIssues(issues);

        // check for a change of status
        let newStatus = this._checkStatus(this.status);
        if(this.status.label !== newStatus.label) {
            console.log(`I was ${this.status.label}, but now I'm ${newStatus.label}`);
            this.status = newStatus;
        }


        // logs the day
        let day = {
            id:this.id,
            address:this.address,
            date:this.clock.date,
            events:{
                list: events,
                outcomes:{
                    positive:eventsOutcomes.positive,
                    negative:eventsOutcomes.negative
                },
                time: eventsOutcomes.time
            },
            choices,
            activities: {
                actions: choices.actions,
                skips: choices.skips,
                time: actionsOutcomes.time,
                outcomes:{
                    positive:actionsOutcomes.positive,
                    negative:actionsOutcomes.negative
                }
            },
            state:{
                conditions: this.conditions,
                issues:{
                    emerging: issues,
                    outcomes: emergingConditions
                },
                status: this.status
            }
        };
        this._log(day);
        return day;
    }

    _initRole(role){
        let agentRole;
        if(role){
            let roles = ROLES.filter(entry => (entry===role) );
            if(roles.length >= 0){
                agentRole = roles[0];
            }
        }
        if(!agentRole){
            agentRole = Rate.pickOne(ROLES);
        }
        return agentRole;
    }

    _initSkills(skills){
        // init skills
        let skillSet;
        if(skills && Array.isArray(skills)){
            let agentSkills = new Set(skills);
            // generate new conditions
            skillSet = this.SKILLS.filter(skill=>{
                return (agentSkills.has(skill.label));
            });
        }
        if(!skillSet){
            // random init
            skillSet = SKILLS.filter(s=>Rate.test(s.rate));
        }
        return skillSet.reduce((s,e)=>{
            s.set(e.label,e);
            return s;
        },new Map());
    }


    // decide how to allocate daily hours
    _decideActions(dailies) {
        let choices = dailies.reduce((partial, action) => {
            if (partial.allocated <= this.HOURS && Rate.test(action.rate)) {
                partial.allocated += action.duration.hours;
                partial.actions.push(action);
            } else {
                partial.skips.push(action);
            }
            return partial;
        }, {actions: [], skips: [], allocated: 0});
        // console.log(`Allocated ${choices.allocated} hours`);
        // console.log('what agent wish to do', choices.actions);
        // console.log('what agent wish to skip', choices.skips);
        return choices;
    }


    _checkStatus(status){
        let current = status;
        if(typeof status !== 'string'){
            current = status.label;
        }
        // console.log(`check status from being "${current}" among the list \n`,STATUS);
        // get list of status which allow current status to transit from
        let declineList = STATUS
            .filter(e => this._checkFrom(e,'decline',current) )
            .filter(e => this._checkFactors(e.decline.factors) );
        // console.log(`Am i declining?\n`,declineList);

        let improveList = STATUS
            .filter(e => this._checkFrom(e,'improve',current) )
            .filter(e => this._checkFactors(e.improve.factors) );
        // console.log(`Am i improving?\n`,improveList);

        // check decline
        if(declineList.length > 0){
            return declineList[0];
        }
        // check improvement
        if(improveList.length > 0){
            return improveList[0];
        }

        return status;
    }

    _checkFrom(e,field,status){
        // same state
        if(e.label === status){return false;}
        // check it is a decline and include current state in the from list
        if(!e || !e[field] || !e[field].from){
            return false;
        }
        return new Set(e[field].from).has(status);
    }

    _checkFactors(factors){
        return factors.reduce((partial,f)=>{
            // check requirements
            if(f.factor === 'age' && this.age < f.severity){
                return false;
            }else if(f.type === 'condition' && !this.conditionsHelper.has(f.type) ){
                return false;
            }
            // test rate
            return (partial && Rate.test(f.rate) );

        },true);
    }

    _mergeOutcomes(list=[]){
        return list.reduce((partial,outcomes)=>{
            return mergeMaps(partial,outcomes);
        },);
    }


    // todo log service
    _log(entry){
        console.log('This morning I got involved in',entry.events);
        console.log('About my activities');
        console.log(`I spent ${entry.activities.time} hours doing: \n`,entry.activities.actions);
        console.log('With these positive outcomes: \n',entry.activities.outcomes.positive);
        console.log(`But I did not manage to: \n`,entry.activities.skips);
        console.log('With these negative outcomes',entry.activities.outcomes.negative);

        console.log(`At the end of the day, i have the following:\n`,entry.state.conditions);
        console.log(`Which results in being "${entry.state.status.label}"`);
        console.log(`With new emerging issues: \n`,entry.state.issues.emerging);
        console.log(`and outcomes:\n`,entry.state.issues.outcomes);


        // apply monitoring systems to the user
        this._monitoring(entry);


        // todo save in the log key: value store
        // agent: date:
    }

    _monitoring(entry){
        if(!this.messaging || !this.monitoring){return }

        Monitoring.forEach(monitor=>{
            try{
                let payload = monitor.process(entry);
                if(payload){
                    this.messaging.send(payload);
                }

            }catch (err){
                console.error(`Error in monitoring with monitor ${monitor.label}\n`,err);
            }
        })
    }

};