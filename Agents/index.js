// init agents from users, registers agents in users status

// each agent is initialised with:
// 1) the community clock
// 2) condition generator
// 3) status generator
// 4) event generator
// 5) action generator

// agent has internal phases defined by
// list of actions he can perform
// preferences
// in training
// use emerging events as a malus for the next round of actions


// going out of the area > bring modifiers

// the delta of outcomes > create new conditions? or trigger emergency?

// pipeline of interventions to be done, eventually the next day?

// degree of relations between agents
import uniqid from 'uniqid';
import Actions from '../Actions/index.js';
import Conditions from '../Conditions/index.js';
import Interact from "../Interact/index.js";
import Utils from '../../Utils/index.js';
import STATUS from './status.js';
import SKILLS from './skills.js';
import ROLES from './roles.js';
import Bootstrap from "../../Bootstrap/index.js";

const Time = Utils.time;
const Messages = Interact.messaging;
const Rate = Utils.rate;
const mergeMaps = Utils.mergeMaps;
const userGenerator = new Bootstrap.users();


export default class Agent{
    // input the state of the agent
    // {age, conditions, state, role, skills}
    // otherwise it is generated by the class
    HOURS = 24;
    YEAR = 1990;

    LOG = false;

    constructor(agent = {},
                clock = new Time.Clock('day'),
                board ){
        // time to allocate during the day
        this.clock = clock;

        let {
            id = uniqid("agent-"),
            days = 0,
            conditions,
            simulation = uniqid("sim-"),
            role,
            skills,
            final = false,
            status = Rate.pickOne(STATUS),
            yearOfBirth = this.YEAR
        } = agent;

        this.id = id;
        this.days = days;
        this.status = status;
        this.final = final;
        this.simulation = simulation;
        this.yearOfBirth = yearOfBirth;

        // init role
        this.role = this._initRole(role);
        // console.log('agent role',this.role);
        //init skills (provided or randomly generated
        this.skillsMap = this._initSkills(skills);
        // console.log('agent skills',this.skillsMap);

        // init helpers
        this.actionsHelper = new Actions();
        // init conditions helper
        this.conditionsHelper = new Conditions({age:this.age,conditions});

        // todo check which monitoring system apply
        // generate a list using rates

        // if billboard provided, enable messaging
        if(board){
            this.messaging = new Messages(board);
        }

        // save

    }
    get age(){
        if(this.yearOfBirth){
            return this.clock.age(this.yearOfBirth);
        }
        return this.clock.age(this.YEAR);
    }


    // returns an array with the current conditions of the agent
    get conditions(){
        return Array.from(this.conditionsHelper.status);
    }
    get skills(){
        return Array.from(this.skillsMap.values());
    }
    get stats(){
        return this.conditionsHelper.stats;
    }

    get getDescription(){
        return {
            agent: this.id,
            simulation: this.simulation,
            role:this.role,
            skills: this.skills,
            yearOfBirth: this.yearOfBirth,
            ...this.description
        };
    }


    //
    async dailyRoutine(events = []){
        // console.log("3",events);
        return new Promise((resolve, reject)=>{
            let time = 0;

            // console.log("4",this.final);
            // check if the agent closed its lifecycle
            if(this.final){
                reject({status:this.status,final:true,id:this.id});
            }
            // console.log("5");
            let eventsOutcomes = this._evaluateEvents(events);
            // console.log("6",eventsOutcomes);
            // update time spent
            time += eventsOutcomes.time;

            // daily actions
            let {choices, actionsOutcomes} = this._dailyActions(this.conditions,time);

            // evaluate the day
            let {issues, emergingConditions} = this._assessDayOutcomes({actionsOutcomes,eventsOutcomes});


            // check for a change of status
            let newStatus = this._checkStatus(this.status);
            // todo change to state machine
            if(this.status.label !== newStatus.label) {
                // console.log(`I was ${this.status.label}, but now I'm ${newStatus.label}`);
                this.status = newStatus;
                if(this.status.type === "final"){
                    this.final = true;
                }
            }

            // console.log("10",newStatus);
            // update days counter
            this.days ++;

            // logs the day
            // todo smart logging
            // reduce to labels
            let day = {
                agent:this.id,
                day: this.days,
                time,
                simulation: this.simulation,
                events:{
                    list: events.map(e=>e.label),
                    outcomes:{
                        positive:Utils.mapToObject(eventsOutcomes.positive),
                        negative:Utils.mapToObject(eventsOutcomes.negative)
                    },
                    time: eventsOutcomes.time
                },
                activities: {
                    actions: choices.actions.map(e=>e.label),
                    skips: choices.skips.map(e=>e.label),
                    time: actionsOutcomes.time,
                    outcomes:{
                        positive:Utils.mapToObject(actionsOutcomes.positive),
                        negative:Utils.mapToObject(actionsOutcomes.negative)
                    }
                },
                state:{
                    age: this.age,
                    conditions: this.conditions,
                    issues:{
                        emerging: issues,
                        outcomes: Utils.mapToObject(emergingConditions)
                    },
                    status: this.status.label,
                    stats: this.stats
                }
            };
            // console.log("11",day);
            this._log(day);
            resolve(day);
        });
    }

    // cleanup store
    async closeUp(){
        return new Promise((resolve,reject)=>{
            // if local store > delete
            resolve("nothing to cleanup")
        });
    }

    _initRole(role){
        let agentRole;
        if(role){
            let roles = ROLES.filter(entry => (entry===role) );
            if(roles.length >= 0){
                agentRole = roles[0];
            }
        }
        if(!agentRole){
            agentRole = Rate.pickOne(ROLES);
        }
        return agentRole;
    }

    _initSkills(skills){
        // init skills
        let skillSet;
        if(skills && Array.isArray(skills)){
            let agentSkills = new Set(skills);
            // generate new conditions
            skillSet = this.SKILLS.filter(skill=>{
                return (agentSkills.has(skill.label));
            });
        }
        if(!skillSet){
            // random init
            skillSet = SKILLS.filter(s=>Rate.test(s.rate));
        }
        return skillSet.reduce((s,e)=>{
            s.set(e.label,e);
            return s;
        },new Map());
    }

    _evaluateEvents(events){
        // evaluate impact of events
        // console.log('today events',events);
        let eventsEffects = events.reduce((partial,event)=>{
            // console.log(event.effects);
            partial.action = partial.action.concat(event.action);
            partial.condition = partial.condition.concat(event.condition);
            return partial;
        },{action:[],condition:[]});
        // console.log('effects of events, actions\n',eventsEffects.action);
        // console.log('effects of events, conditions\n',eventsEffects.condition);
        // add conditions
        this.conditionsHelper.add(eventsEffects.condition);

        // assess events actions
        return this.actionsHelper.outcomes(eventsEffects.action,[],this.conditionsHelper.list);
    }

    _dailyActions(conditions,time){
        // get reminders of daily activities
        let dailies = this.actionsHelper.remind(conditions);
        // console.log("7",dailies);
        // decide what to do and skip
        let choices = this._decideActions(dailies);
        // console.log("8",choices);
        // IMPORTANT it can be done in bulk or cycle (for the sake of logs)
        // evaluate outcomes of actions
        let actionsOutcomes = this.actionsHelper.outcomes(
            choices.actions,
            choices.skips,
            this.conditionsHelper.list,
            time);
        // console.log("9",actionsOutcomes);


        return {choices, actionsOutcomes};
    }


    // decide how to allocate daily hours
    _decideActions(dailies) {
        let choices = dailies.reduce((partial, action) => {
            if (partial.allocated <= this.HOURS && Rate.test(action.rate)) {
                partial.allocated += action.duration.hours;
                partial.actions.push(action);
            } else {
                partial.skips.push(action);
            }
            return partial;
        }, {actions: [], skips: [], allocated: 0});
        // console.log(`Allocated ${choices.allocated} hours`);
        // console.log('what agent wish to do', choices.actions);
        // console.log('what agent wish to skip', choices.skips);
        return choices;
    }


    _assessDayOutcomes({actionsOutcomes,eventsOutcomes}){
        // IMPORTANT AS BULK //
        // translate outcomes to conditions
        let positive = this._mergeOutcomes([actionsOutcomes.positive,eventsOutcomes.positive]);
        let negative = this._mergeOutcomes([actionsOutcomes.negative,eventsOutcomes.negative]);
        // console.log('consolidate positive',positive);
        // console.log('consolidate negative',negative);
        let issues = this.conditionsHelper.assess(positive,negative);
        // console.log('emerging issues',issues);
        // issues : object {type:weight} (condition type)
        // add for emerging conditions using emerging issues
        let emergingConditions = this.conditionsHelper.addIssues(issues);

        return {issues, emergingConditions};
    }


    _checkStatus(status){
        let current = status;
        if(typeof status !== 'string'){
            current = status.label;
        }
        // console.log(`check status from being "${current}" among the list \n`,STATUS);
        // get list of status which allow current status to transit from
        let declineList = STATUS
            .filter(e => this._checkFrom(e,'decline',current) )
            .filter(e => this._checkFactors(e.decline.factors) );
        // console.log(`Am i declining?\n`,declineList);

        let improveList = STATUS
            .filter(e => this._checkFrom(e,'improve',current) )
            .filter(e => this._checkFactors(e.improve.factors) );
        // console.log(`Am i improving?\n`,improveList);

        // check decline
        if(declineList.length > 0){
            return declineList[0];
        }
        // check improvement
        if(improveList.length > 0){
            return improveList[0];
        }

        return status;
    }

    _checkFrom(e,field,status){
        // same state
        if(e.label === status){return false;}
        // check it is a decline and include current state in the from list
        if(!e || !e[field] || !e[field].from){
            return false;
        }
        return new Set(e[field].from).has(status);
    }

    _checkFactors(factors){
        return factors.reduce((partial,f)=>{
            // check requirements
            if(f.factor === 'age' && this.age < f.severity){
                return false;
            }else if(f.type === 'condition' && !this.conditionsHelper.has(f.type) ){
                return false;
            }
            // test rate
            return (partial && Rate.test(f.rate) );

        },true);
    }

    _mergeOutcomes(list=[]){
        return list.reduce((partial,outcomes)=>{
            return mergeMaps(partial,outcomes);
        },);
    }



    _log(entry){
        if(this.LOG) {
            console.log(`This morning I got involved for ${entry.events.time} hours in\n`,entry.events.list.join(", "));
            console.log('With outcomes \n',entry.events.outcomes);
            console.log('About my activities');
            console.log(`I spent ${entry.activities.time} hours doing: \n`,entry.activities.actions.join(", "));
            console.log('With these positive outcomes: \n',entry.activities.outcomes.positive);
            console.log(`But I did not manage to: \n`,entry.activities.skips.join(", "));
            console.log('With these negative outcomes',entry.activities.outcomes.negative);
            console.log(`At the end of the day, i have the following:\n`,entry.state.conditions.map(e=>e.duration+" "+e.label).join(", "));
            console.log(`Which results in being "${entry.state.status.label}"`);
            console.log(`Here my stats`,entry.state.stats);
            console.log(`With new emerging issues: \n`,entry.state.issues.emerging);
            console.log(`and outcomes:\n`,entry.state.issues.outcomes);
            console.log("1");
        }
    }

};